### جدول اصلاح موارد نقض

حسین شریعتی

| اصل | کلاس تغییر یافته | مشکل در نسخه قبلی | اقدام اصلاحی / رفع نقض |
|------|------------------|--------------------|--------------------------|
| **SRP** | `ReservationService` | این کلاس مسئولیت‌های متعددی داشت شامل مدیریت رزرو، اعمال تخفیف، پردازش پرداخت، تولید فاکتور و ارسال اعلان. این ترکیب مسئولیت‌ها باعث نقض اصل مسئولیت یگانه می‌شد. | منطق رزرو به متدهای جداگانه تقسیم شد: `applyLocationBasedDiscount()`، `executePaymentProcess()`، `generateInvoice()` و `sendConfirmationNotification()`. هر متد تنها یک وظیفه مشخص دارد و کلاس به عنوان هماهنگ‌کننده عمل می‌کند. |
| **OCP** | `PaymentProcessor` | برای افزودن روش پرداخت جدید، نیاز به تغییر در کلاس `ReservationService` و `PaymentProcessor` بود. این یعنی کلاس‌ها نسبت به توسعه بسته بودند. | تصمیم‌گیری در مورد نوع پرداخت به داخل کلاس `PaymentProcessor` منتقل شد و از Enum `PaymentMethods` استفاده می‌شود. حالا می‌توان روش‌های جدید پرداخت را تنها با افزودن case جدید در متد `executePayment()` اضافه کرد بدون نیاز به تغییر کد موجود. |
| **LSP** | `LuxuryRoom` ← `Room` | کلاس `LuxuryRoom` رفتار متفاوتی در محاسبه قیمت داشت که باعث می‌شد جایگزینی آن با `Room` مشکل ایجاد کند. | متد `calculateTotal()` در `LuxuryRoom` به‌گونه‌ای بازنویسی شد که ابتدا قیمت پایه را از کلاس والد محاسبه می‌کند و سپس هزینه اضافی luxury را اضافه می‌کند. حالا هر دو کلاس رفتار سازگاری دارند و اصل جانشینی رعایت شده است. |
| **ISP** | `MessageSender`, `EmailSender`, `SmsSender` | اینترفیس `MessageSender` در نسخه قبلی متدهای متعددی داشت که همه کلاس‌های پیاده‌کننده مجبور بودند آن‌ها را پیاده‌سازی کنند حتی اگر استفاده نمی‌کردند. | اینترفیس به یک متد واحد `deliver()` ساده‌سازی شد. کلاس‌های `EmailSender` و `SmsSender` هرکدام پیاده‌سازی خاص خود را دارند و فقط متد مورد نیاز را پیاده‌سازی می‌کنند. اصل جداسازی رابط‌ها رعایت شده است. |

---

## جدول اصلاح موارد نقض

علیرضا جعفرپور

| اصل | کلاس تغییر یافته | مشکل در نسخه قبلی | اقدام اصلاحی / رفع نقض |
|------|------------------|--------------------|--------------------------|
| **DIP** | `ReservationService` | این کلاس مستقیماً به کلاس‌های پیاده‌سازی مانند `EmailSender` و `SmsSender` وابسته بود و آن‌ها را با `new` ایجاد می‌کرد. این وابستگی مستقیم به جزئیات باعث نقض اصل وارونگی وابستگی می‌شد. | وابستگی‌ها از پیاده‌سازی به abstraction منتقل شدند. متد `createMessageSender()` با استفاده از اینترفیس `MessageSender` ایجاد شد و نمونه مناسب بر اساس نوع اعلان ساخته می‌شود. کلاس اکنون تنها با سطوح انتزاع کار می‌کند و اصل DIP برقرار است. |
| **PLK** | `Customer`, `Room`, `ReservationService` | کلاس‌ها برای دسترسی به داده‌های داخلی یکدیگر مستقیماً به فیلدهای public دسترسی داشتند (مثل `customer.name` یا `room.price`) که وابستگی شدید و اطلاع زیاد از جزئیات ایجاد می‌کرد. | فیلدها private شدند و متدهای getter مانند `getName()`، `getEmail()`، `getPrice()` و `isLocatedIn()` اضافه شدند. اکنون هیچ کلاسی به ساختار داخلی دیگری وابسته نیست و دسترسی از طریق متدهای عمومی انجام می‌شود. اصل Law of Demeter رعایت شده است. |
| **CRP** | `Reservation`, `ReservationService` | منطق پردازش پرداخت و ارسال اعلان مستقیماً در کلاس `ReservationService` پیاده‌سازی شده بود و استفاده مجدد از این منطق در سایر بخش‌ها دشوار بود. | طراحی اصلاح شد تا از ترکیب (Composition) استفاده شود. کلاس `ReservationService` از `PaymentProcessor` و `MessageSender` استفاده می‌کند و وابستگی‌ها از طریق constructor و متدهای کمکی تزریق می‌شوند. این باعث می‌شود کد قابل استفاده مجدد باشد و اصل Common Reuse Principle رعایت شود. |

