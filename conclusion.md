## گام پنجم – نتیجه‌گیری (بخش ۱)

### مروری بر دستاوردهای طراحی و نقش اصول شی‌گرایی در نگهداری نرم‌افزار

**حسین شریعتی:**

هدف اصلی این پروژه بهبود کیفیت ساختار کد و قابلیت نگهداری نرم‌افزار با استفاده از اصول بنیادین شی‌گرایی بود. تجربه بازطراحی سیستم نشان داد که رعایت اصول **SOLID** نه‌تنها باعث نظم و خوانایی در کد می‌شود، بلکه به‌طور مستقیم بر **پایداری، قابلیت تست، و گسترش‌پذیری** سیستم تأثیر مثبت دارد.

در نسخه اولیه برنامه، هر کلاس مجموعه‌ای از وظایف مختلف را بر عهده داشت. برای مثال، کلاس `ReservationService` علاوه بر مدیریت عملیات رزرو، مسئولیت پردازش پرداخت و ارسال اعلان را نیز به دوش می‌کشید. این مسئله موجب وابستگی بالا و تداخل مسئولیت‌ها شده بود. به بیان دیگر، تغییر در یکی از قابلیت‌ها می‌توانست منجر به خطا در بخش‌های دیگر شود و نیاز به بازآزمایی کامل سیستم را ایجاد کند.

پس از اعمال بازطراحی در گام سوم، سیستم به ساختاری **ماژولار و تفکیک‌شده** تبدیل شد. اکنون هر کلاس یک مسئولیت مشخص دارد و از طریق **رابط‌های انتزاعی (Interfaces)** با سایر اجزا ارتباط برقرار می‌کند. این تغییر نه‌تنها باعث ساده‌تر شدن آزمون و نگهداری شد، بلکه امکان افزودن قابلیت‌های جدید را بدون تغییر در کدهای موجود فراهم کرد، که خود بیانگر رعایت اصل **Open/Closed Principle (OCP)** است.

در واقع، رعایت اصولی همچون **SRP (اصل تک‌مسئولیتی)**، **OCP (اصل باز/بسته)** و **DIP (اصل وارونگی وابستگی)** موجب شد نرم‌افزار انعطاف‌پذیر و مقاوم در برابر تغییر گردد. در چنین معماری‌ای، افزودن قابلیت جدید (مثلاً روش جدید پرداخت یا ارسال اعلان) فقط با ایجاد یک کلاس جدید انجام می‌شود و نیازی به تغییر در کلاس‌های قبلی نیست.

به‌علاوه، رعایت اصل **LSP (جانشینی لیسکوف)** تضمین کرد که زیرکلاس‌ها بدون ایجاد تناقض در رفتار، بتوانند در جایگاه ابرکلاس‌ها استفاده شوند. بدین ترتیب، حذف یا جایگزینی اشیاء در لایه‌های مختلف سیستم بدون تأثیر منفی بر عملکرد آن امکان‌پذیر شد.

در نتیجه، ساختار فعلی پروژه نه‌تنها پایدارتر و قابل فهم‌تر است، بلکه توسعه‌دهندگان جدید هم می‌توانند با صرف حداقل زمان، منطق کد را درک و بدون خطر، آن را گسترش دهند. این ویژگی جوهره اصلی "قابلیت نگهداری" (Maintainability) است که در نرم‌افزارهای واقعی ارزش حیاتی دارد.

---

## گام پنجم – نتیجه‌گیری (بخش ۲)

### تحلیل تأثیر اصول شی‌گرایی بر هزینه، زمان و کیفیت نگهداری سیستم

**علیرضا جعفرپور:**

تحلیل بازدهی پروژه در سه منظر اصلی — یعنی **هزینه تغییر، زمان توسعه و پایداری ساختار** — نشان می‌دهد رعایت اصول شی‌گرایی از ابتدای پروژه، هزینه‌های بلندمدت نگهداری را به‌شدت کاهش می‌دهد.

در طراحی اولیه، افزودن هر قابلیت کوچک مستلزم تغییر در چند کلاس مختلف بود. به همین دلیل، تیم توسعه ناچار می‌شد چرخه کامل تست و بازبینی را برای هر تغییر کوچک تکرار کند. این فرایند ضمن افزایش زمان تحویل، احتمال بروز خطاهای جانبی (Side Effects) را بالا می‌برد.

اما در نسخه بازطراحی‌شده، به دلیل تفکیک وظایف و جداسازی وابستگی‌ها، حتی تغییرات اساسی نیز در محدوده یک کلاس یا ماژول انجام می‌گیرد.

به این ترتیب:
- **هزینه تغییر (Cost of Change)** کاهش یافت
- تعداد خطوطی که نیاز به ویرایش داشتند به کمتر از نصف رسید
- اجرای تست واحد (Unit Test) برای اجزای جداگانه ساده‌تر شد
- امکان **تبدیل پروژه کوچک به یک سیستم مقیاس‌پذیر (Scalable)** فراهم گردید

به‌علاوه، رعایت اصول **ISP (تفکیک رابط‌ها)** و **PLK (قانون دمیلتر)** کمک کرد تا کلاس‌ها تنها از واسط‌های موردنیاز خود استفاده کنند و از جزئیات درونی سایر کلاس‌ها بی‌خبر بمانند. این موضوع منجر به افزایش "انسجام درونی" و کاهش "وابستگی بیرونی" در سراسر سیستم شد؛ ویژگی‌ای که از اصلی‌ترین ملاک‌های **نگهداری‌پذیری نرم‌افزار (Software Maintainability)** است.

اصل **CRP (اصل Reuse)** نیز این امکان را فراهم کرد تا کلاس‌ها و مؤلفه‌های نوشته‌شده در نسخه‌های بعدی نیز قابل استفاده مجدد باشند. بدین‌ترتیب، تیم توسعه می‌تواند در پروژه‌های آینده، بدون نیاز به بازطراحی کامل، از اجزای فعلی به‌عنوان زیرساخت استفاده کند.

در مجموع، حاصل کار پروژه نشان داد که رعایت اصول شی‌گرایی از همان مرحله تحلیل و طراحی، نقشی کلیدی در **کاهش پیچیدگی، افزایش انعطاف، و تسهیل نگهداری** دارد.

> **نتیجه نهایی:**  
> رعایت اصول شی‌گرایی باعث می‌شود نرم‌افزار از حالت ایستا و شکننده خارج شده و به یک ساختار پویا، مقیاس‌پذیر، قابل توسعه و پایدار تبدیل شود. در نتیجه، تیم توسعه می‌تواند با حداقل هزینه و زمان، نرم‌افزار را به‌روزرسانی کند، بدون آنکه کیفیت یا عملکرد سیستم قربانی شود.

