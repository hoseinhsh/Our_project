## گام پنجم – نتیجه‌گیری (بخش ۱)

### مروری بر دستاوردهای طراحی و نقش اصول شی‌گرایی در نگهداری نرم‌افزار

**حسین شریعتی:**

هدف اصلی این پروژه بهبود کیفیت ساختار کد و قابلیت نگهداری نرم‌افزار با استفاده از اصول بنیادین شی‌گرایی بود. تجربه بازطراحی سیستم نشان داد که رعایت اصول **SOLID** نه‌تنها باعث نظم و خوانایی در کد می‌شود، بلکه به‌طور مستقیم بر **پایداری، قابلیت تست، و گسترش‌پذیری** سیستم تأثیر مثبت دارد.

در نسخه اولیه برنامه، هر کلاس مجموعه‌ای از وظایف مختلف را بر عهده داشت. برای مثال، کلاس `ReservationService` علاوه بر مدیریت عملیات رزرو، مسئولیت پردازش پرداخت و ارسال اعلان را نیز به دوش می‌کشید. این مسئله موجب وابستگی بالا و تداخل مسئولیت‌ها شده بود. به بیان دیگر، تغییر در یکی از قابلیت‌ها می‌توانست منجر به خطا در بخش‌های دیگر شود و نیاز به بازآزمایی کامل سیستم را ایجاد کند.

پس از اعمال بازطراحی در گام سوم، سیستم به ساختاری **ماژولار و تفکیک‌شده** تبدیل شد. اکنون هر کلاس یک مسئولیت مشخص دارد و از طریق **رابط‌های انتزاعی (Interfaces)** با سایر اجزا ارتباط برقرار می‌کند. این تغییر نه‌تنها باعث ساده‌تر شدن آزمون و نگهداری شد، بلکه امکان افزودن قابلیت‌های جدید را بدون تغییر در کدهای موجود فراهم کرد، که خود بیانگر رعایت اصل **Open/Closed Principle (OCP)** است.

در واقع، رعایت اصولی همچون **SRP (اصل تک‌مسئولیتی)**، **OCP (اصل باز/بسته)** و **DIP (اصل وارونگی وابستگی)** موجب شد نرم‌افزار انعطاف‌پذیر و مقاوم در برابر تغییر گردد. در چنین معماری‌ای، افزودن قابلیت جدید (مثلاً روش جدید پرداخت یا ارسال اعلان) فقط با ایجاد یک کلاس جدید انجام می‌شود و نیازی به تغییر در کلاس‌های قبلی نیست.

به‌علاوه، رعایت اصل **LSP (جانشینی لیسکوف)** تضمین کرد که زیرکلاس‌ها بدون ایجاد تناقض در رفتار، بتوانند در جایگاه ابرکلاس‌ها استفاده شوند. بدین ترتیب، حذف یا جایگزینی اشیاء در لایه‌های مختلف سیستم بدون تأثیر منفی بر عملکرد آن امکان‌پذیر شد.

در نتیجه، ساختار فعلی پروژه نه‌تنها پایدارتر و قابل فهم‌تر است، بلکه توسعه‌دهندگان جدید هم می‌توانند با صرف حداقل زمان، منطق کد را درک و بدون خطر، آن را گسترش دهند. این ویژگی جوهره اصلی "قابلیت نگهداری" (Maintainability) است که در نرم‌افزارهای واقعی ارزش حیاتی دارد.

