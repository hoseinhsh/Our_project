## گام چهارم – ارزیابی (حسین شریعتی)

### تحلیل تأثیر رعایت اصول طراحی بر قابلیت توسعه و نگهداری سیستم

در گام‌های دوم و سوم مشخص شد که مشکلات اصلی طراحی نسخه اولیه از عدم رعایت اصول بنیادین شی‌گرایی مانند **SRP، OCP، LSP، ISP، DIP، PLK و CRP** ناشی می‌شد. این وضعیت باعث شده بود که بخش‌های مختلف سیستم به‌شدت به یکدیگر وابسته باشند و هر تغییر یا افزودن ویژگی جدید نیازمند ویرایش چندین فایل و کلاس شود.

در نسخه اولیه، کلاس‌های اصلی مانند `ReservationService`، `Reservation`، `Customer` و `Room` هم‌زمان چندین نقش را بر عهده داشتند. بخشی از آن‌ها مسئول مدیریت منطق رزرو، بخشی دیگر مسئول ارتباطات و حتی بخشی مسئول پردازش پرداخت و ارسال اعلان بودند. این در حالی است که اصول شی‌گرایی می‌گوید هر کلاس باید دقیقاً **یک مسئولیت واحد** داشته باشد تا تغییر در یک بخش از سیستم بر سایر بخش‌ها تأثیر منفی نگذارد.

زمانی که در گام اول دو قابلیت جدید — یعنی **افزودن روش پرداخت حضوری (`onSitePayment`)** و **افزودن روش ارسال پیامک (`sendSmsMessage`)** — اضافه شدند، توسعه‌دهندگان مجبور شدند چندین کلاس را تغییر دهند. این مسئله نه‌تنها منجر به تکرار کد شد، بلکه باعث افزایش ریسک خطا و دشواری در تست نرم‌افزار نیز گردید.

اما با اعمال بازطراحی در گام سوم، وابستگی‌های مستقیم به کلاس‌های پیاده‌سازی (Concrete Classes) حذف شد و به جای آن‌ها ساختار انتزاعی (Interfaces) اضافه شد. به این ترتیب، هر کلاس اکنون تنها از طریق سطوح انتزاع با سایر اجزا ارتباط دارد؛ یعنی دقیقاً همان مفهومی که **اصل وارونگی وابستگی (DIP)** بر آن تأکید می‌کند.

همچنین با پیاده‌سازی **قانون دمیلتر یا "اصل کمترین آگاهی" (PLK)**، دیگر هیچ کلاسی وارد جزئیات داخلی کلاس‌های دیگر نمی‌شود، بلکه برای انجام وظایف خود از متدهای واسط استفاده می‌کند. این رویکرد هم انسجام درونی هر کلاس را افزایش داده و هم میزان وابستگی میان اجزا را کاهش داده است.

نتیجه مستقیم رعایت این اصول آن است که اکنون اگر تیم توسعه بخواهد قابلیت جدیدی به پروژه اضافه کند، دیگر نیازی به تغییر در کلاس‌های قبلی نیست. کافی است فقط یک کلاس جدید بسازد که Interface مربوطه را پیاده‌سازی کند. این همان چیزی است که **اصل باز-بسته (Open/Closed Principle)** وعده می‌دهد: کد باید برای *گسترش* باز باشد، اما برای *تغییر* بسته بماند.

---

## گام چهارم – ارزیابی (علیرضا جعفرپور)

### مقایسه تحلیلی بین نسخه اولیه و نسخه بازطراحی شده

برای روشن‌سازی تأثیر رعایت اصول شی‌گرایی، می‌توان تفاوت میان مرحله اولیه و طراحی بهینه را از جنبه‌های مختلف بررسی کرد:

#### 1. در نسخه اولیه (بدون رعایت اصول)

توسعه قابلیت جدید الزاماً منجر به بازنویسی بخش‌هایی از کلاس‌های `ReservationService`، `PaymentProcessor` و `MessageSender` می‌شد. هر تغییر مستلزم بازآزمایی کامل بخش‌های وابسته نیز بود. در عمل، افزودن دو قابلیت فوق حدود **۵ تا ۶ تغییر در فایل‌های مختلف** ایجاد کرد و ساختار کلی کد را شکننده‌تر نمود.

**تغییرات مورد نیاز:**
- تغییر در `ReservationService` برای افزودن case جدید در switch
- تغییر در `PaymentProcessor` برای افزودن متد جدید
- تغییر در `MessageSender` برای افزودن متد جدید
- تغییر در `Notifier` یا `PaymentMethods` enum
- تغییر در `Customer` برای افزودن فیلد جدید (در صورت نیاز)
- نیاز به بازآزمایی تمام بخش‌های وابسته

#### 2. در نسخه بازطراحی‌شده (پس از رعایت اصول)

توسعه همان قابلیت‌ها فقط نیازمند ایجاد **دو کلاس جدید مستقل** بود (`SmsSender` و یک کلاس پردازشگر پرداخت جدید) بدون اینکه حتی یک خط از کدهای فعلی تغییر کند. این تغییر به معنای رعایت کامل اصول **OCP**، **DIP** و **CRP** است؛ یعنی وابستگی به پیاده‌سازی‌ها حذف شده، استفاده مجدد از کد افزایش یافته و نگهداری نرم‌افزار ساده‌تر شده است.

**تغییرات مورد نیاز:**
- ایجاد کلاس جدید که Interface مربوطه را پیاده‌سازی می‌کند
- افزودن مقدار جدید به Enum (در صورت نیاز)
- بدون نیاز به تغییر در کلاس‌های موجود
- بدون نیاز به بازآزمایی گسترده

#### 3. تحلیل هزینه تغییر (Cost of Change)

از دید تجزیه‌وتحلیل هزینه تغییر می‌توان گفت:

- **نسخه اولیه:** هزینه افزودن قابلیت جدید = **۵-۶ تغییر در کلاس‌های مختلف** + نیاز به بازآزمایی کامل
- **نسخه بازطراحی شده:** هزینه افزودن قابلیت جدید = **۱-۲ تغییر (افزودن کلاس جدید)** + تست محدود

این یعنی کاهش حدود **۶۰-۷۰٪ در تغییرات لازم** برای توسعه. علاوه بر کمیت تغییر، کیفیت ساختار نیز به‌شدت ارتقا یافته است: اکنون سیستم گسترش‌پذیر، تست‌پذیر و ایمن در برابر شکستن وابستگی‌هاست.

#### 4. مزایای طراحی بهینه

- **قابلیت تست:** کلاس‌ها به‌راحتی قابل تست هستند زیرا وابستگی‌ها از طریق Interface تزریق می‌شوند
- **قابلیت نگهداری:** تغییر در یک بخش تأثیری بر سایر بخش‌ها ندارد
- **قابلیت توسعه:** افزودن قابلیت جدید بدون تغییر کد موجود امکان‌پذیر است
- **کاهش ریسک:** احتمال بروز باگ در تغییرات کاهش یافته است

---

### جمع‌بندی نهایی

اگر اصول شی‌گرایی از ابتدا در طراحی رعایت می‌شدند:
- تغییر‌های مرحله اول کاملاً **حذف** می‌شدند (هیچ کلاس قبلی نیاز به ویرایش نداشت)
- هر دو قابلیت جدید فقط با افزودن **دو کلاس جدید** (بدون تغییر در کدهای دیگر) به پروژه اضافه می‌شدند
- نگهداری و آزمون پروژه آسان‌تر می‌شد و توسعه‌های آینده مستقل از ساختار فعلی ادامه می‌یافت

در نتیجه رعایت **اصول SOLID از همان ابتدا** می‌توانست زمان توسعه را کوتاه‌تر، ساختار را پایدارتر، و هزینه نگهداری را به‌طور قابل‌توجهی کاهش دهد. چنین طراحی‌ای نه‌تنها از تکرار و درهم‌تنیدگی وظایف جلوگیری می‌کند، بلکه زمینه‌ساز تحول پروژه به یک چارچوب ماژولار و قابل توسعه در آینده خواهد بود.

